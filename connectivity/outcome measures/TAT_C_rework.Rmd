---
title: "calculating"
author: "Mikkel Werling & Victor M?ller"
date: "5/18/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Set working directory & load libraries. 

```{r}

setwd("~/CRUST-1/data/tests")

library(tidyverse)

```

loading data for small world 

```{r}

#reading 
path <- "~/CRUST-1/data/tests/"

files <- list.files(path = path, pattern="*.csv") #if possible. 

#taken from the scatter-plot file (reconsider what is needed)
mycols <- c("replica", 
            "colab_cond",
            "network", 
            "population", 
            "sigma",
            "net_size",
            "base_SS",
            "true_model",
            "prop_1",
            "prop_2",
            "prop_3",
            "prop_4",
            "prop_5",
            "prop_6",
            "prop_7",
            "prop_8",
            "prop_9",
            "prop_10",
            "prop_11",
            "prop_12",
            "prop_13",
            "prop_14",
            "prop_true")

#loading them 
dfList <- lapply(files, function(f) {  
   read.csv(paste0(path, f))[mycols]
})

#subsetting (because of computational demands)
df <- do.call(rbind, dfList) 
rm(dfList)
```

calculating TAT_C for small world.

```{r}

#subsets because of runtime. 
df_2 <- df %>%
  filter(true_model == 2) 

df_7 <- df %>%
  filter(true_model == 7)

df_13 <- df %>%
  filter(true_model == 13)

rm(list=setdiff(ls(), c("df_2", "df_7", "df_13")))

#the indexing is done to make sure that we only get the true model when it is the 
#biggest and not a tie. which.max uses ties method = "first" meaning that the first #column with a tied highest value is the maxprop. Here we place the true_model as #the last column for each true model. 

df_2$maxprop = names(df_2[,c(9, 11:23)])[apply(df_2[,c(9, 11:23)], 1, which.max)]

df_7$maxprop = names(df_7[,c(9:14, 16:23)])[apply(df_7[,c(9:14, 16:23)], 
                                                  1, which.max)]

df_13$maxprop = names(df_13[,c(9:20, 22:23)])[apply(df_13[,c(9:20, 22:23)], 
                                                    1, which.max)]
  
#binding 
df <- rbind(df_2, df_7, df_13)

#mutating 1 for TAT_c & 0 for not TAT_c
df <- df %>%
  mutate(TAT_C = ifelse(maxprop == "prop_true", 1, 0))
  

```

For all variations of parameters: 

```{r}
#All parameters 
TAT_C_table <- df %>%
  group_by(network, population, sigma, net_size, colab_cond, 
           base_SS, true_model) %>%
  summarise(TAT_C = round(mean(TAT_C),2)) 

```

Above chunk: 
Seems that the only thing that matters is sigma. 
When sigma = 0.2 they spend all their time with true consensus.
When sigma = 0.8 they spend no time with true consensus. 

Next chunk: 

```{r}

#Network
TAT_C_network <- df %>%
  group_by(network) %>%
  summarise(TAT_C = round(mean(TAT_C),2)) 

TAT_C_network

#Population
TAT_C_pop <- df %>%
  group_by(population) %>%
  summarise(TAT_C = round(mean(TAT_C),2)) 

TAT_C_pop

#Sigma
TAT_C_sigma <- df %>%
  group_by(sigma) %>%
  summarise(TAT_C = round(mean(TAT_C),2)) 

TAT_C_sigma

#Colab
TAT_C_colab <- df %>%
  group_by(colab_cond) %>%
  summarise(TAT_C = round(mean(TAT_C),2)) 

TAT_C_colab

#True model
TAT_C_mod <- df %>%
  group_by(true_model) %>%
  summarise(TAT_C = round(mean(TAT_C),2)) 

TAT_C_mod

```

Above chunk:
Network: Somewhat higher for SMALL, somewhat lower for TOM. 
Population: No big effect. 
Sigma: Almost 0/1 - this carries all the effect here. 
Colab: No effect. 
Model: Somewhat higher for 2 (.55) than for 13 (.47)

In conclusion sigma carries all the signal. 
We should investigate why the TAT_C = 0 for high sigma.
They shouldn't actively select against the true model.
Perhaps it is because they simply converge to the models 
that their research strategies dictate. 

Next chunk: 
Averaged over some parameters. 

```{r}

#summary stats
TAT_C_table_inc <- TAT_C_table %>%
  group_by(population, network, net_size) %>%
  summarize(TAT_C_median = median(TAT_C),
            TAT_C_mean = mean(TAT_C),
          TAT_C_IQR = IQR(TAT_C))

```

Above chunk: 
waiting for more data from Mikkel to interpret. 

write csv. 

```{r}
#new working directory
setwd("~/CRUST-1/connectivity/outcome_results")

#save 
write.csv(TAT_C_table_inc, file = "TATC_small_100.csv", row.names = FALSE)

#clear environment
rm(list=ls())

```

