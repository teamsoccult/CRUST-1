---
title: "calculating"
author: "Mikkel Werling & Victor M?ller"
date: "5/18/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Set working directory & load libraries. 

```{r}

setwd("~/CRUST-1/data/tests")

library(tidyverse)

```

loading data for small world 

```{r}

#reading 
path <- "~/CRUST-1/data/tests/"

files <- list.files(path = path, pattern="*.csv") #if possible. 

#taken from the scatter-plot file (reconsider what is needed)
mycols <- c("replica", 
            "network", 
            "population", 
            "sigma",
            "net_size",
            "base_SS",
            "true_model",
            "prop_1",
            "prop_2",
            "prop_3",
            "prop_4",
            "prop_5",
            "prop_6",
            "prop_7",
            "prop_8",
            "prop_9",
            "prop_10",
            "prop_11",
            "prop_12",
            "prop_13",
            "prop_14",
            "prop_true")

#loading them 
dfList <- lapply(files, function(f) {  
   read.csv(paste0(path, f))[mycols]
})

#subsetting (because of computational demands)
small <- do.call(rbind, dfList) 
rm(dfList)
```

calculating TAT_C for small world.

```{r}

#subsets because of runtime. 
small_2 <- small %>%
  filter(true_model == 2) 

small_7 <- small %>%
  filter(true_model == 7)

small_13 <- small %>%
  filter(true_model == 13)

rm(list=setdiff(ls(), c("small_2", "small_7", "small_13")))

#computing.
#the indexing is done to make sure that we only get the true model when it is the 
#biggest and not a tie. which.max uses ties method = "first" meaning that the first 
#column with a tied highest value is the maxprop. Here we place the true_model as the
#last column for each true model. 
small_2$maxprop = names(small_2[,c(8, 10:22)])[apply(small_2[,c(8, 10:22)], 1, which.max)]

small_7$maxprop = names(small_7[,c(8:13, 15:22)])[apply(small_7[,c(8:13, 15:22)], 1, which.max)]

small_13$maxprop = names(small_13[,c(8:19, 21:22)])[apply(small_13[,c(8:19, 21:22)], 1, which.max)]
  
#binding 
small <- rbind(small_2, small_7, small_13)

#mutating 1 for TAT_c & 0 for not TAT_c
small <- small %>%
  mutate(TAT_C = ifelse(maxprop == "prop_true", 1, 0))
  
#per pop, network & replica
TAT_C_table <- small %>%
  group_by(replica, population, network, sigma, true_model, net_size, base_SS) %>%
  summarise(TAT_C = mean(TAT_C)) 

#summary stats
TAT_C_table_inc <- TAT_C_table %>%
  group_by(population, network, net_size) %>%
  summarize(TAT_C_median = median(TAT_C),
            TAT_C_mean = mean(TAT_C),
          TAT_C_IQR = IQR(TAT_C))

```

write csv. 

```{r}
#new working directory
setwd("~/CRUST-1/connectivity/outcome_results")

#save 
write.csv(TAT_C_table_inc, file = "TATC_small_100.csv", row.names = FALSE)

#clear environment
rm(list=ls())

```

Set working directory again (prepare for lattice)

```{r}

setwd("~/CRUST-1/data/tests")

```

loading data for lattice

```{r}

#reading 
path <- "~/CRUST-1/data/tests/"

files <- list.files(path = path, pattern="lattice") #if possible. 

#taken from the scatter-plot file (reconsider what is needed)
mycols <- c("replica", 
            "network", 
            "population", 
            "sigma",
            "net_size",
            "base_SS",
            "true_model",
            "prop_1",
            "prop_2",
            "prop_3",
            "prop_4",
            "prop_5",
            "prop_6",
            "prop_7",
            "prop_8",
            "prop_9",
            "prop_10",
            "prop_11",
            "prop_12",
            "prop_13",
            "prop_14",
            "prop_true")

#loading them 
dfList <- lapply(files, function(f) {  
   read.csv(paste0(path, f))[mycols]
})

#subsetting (because of computational demands)
lattice <- do.call(rbind, dfList) 
rm(dfList)
```

calculating TAT_C for small world.

```{r}

#subsets because of runtime. 
lattice_2 <- lattice %>%
  filter(true_model == 2) 

lattice_7 <- lattice %>%
  filter(true_model == 7)

lattice_13 <- lattice %>%
  filter(true_model == 13)

rm(list=setdiff(ls(), c("lattice_2", "lattice_7", "lattice_13")))

#computing.
#the indexing is done to make sure that we only get the true model when it is the 
#biggest and not a tie. which.max uses ties method = "first" meaning that the first 
#column with a tied highest value is the maxprop. Here we place the true_model as the
#last column for each true model. 
lattice_2$maxprop = names(lattice_2[,c(8, 10:22)])[apply(lattice_2[,c(8, 10:22)], 1, which.max)]

lattice_7$maxprop = names(lattice_7[,c(8:13, 15:22)])[apply(lattice_7[,c(8:13, 15:22)], 1, which.max)]

lattice_13$maxprop = names(lattice_13[,c(8:19, 21:22)])[apply(lattice_13[,c(8:19, 21:22)], 1, which.max)]
  
#binding 
lattice <- rbind(lattice_2, lattice_7, lattice_13)

#mutating 1 for TAT_c & 0 for not TAT_c
lattice <- lattice %>%
  mutate(TAT_C = ifelse(maxprop == "prop_true", 1, 0))
  
#per pop, network & replica
TAT_C_table <- lattice %>%
  group_by(replica, population, network, sigma, true_model, net_size, base_SS) %>%
  summarise(TAT_C = mean(TAT_C)) 

#summary stats
TAT_C_table_inc <- TAT_C_table %>%
  group_by(population, network) %>%
  summarize(TAT_C_median = median(TAT_C),
            TAT_C_mean = mean(TAT_C),
          TAT_C_IQR = IQR(TAT_C))

```

write csv. 

```{r}
#new working directory
setwd("C:/Users/victm/Dropbox/CogSci 4/Social and Cultural Dynamics in Cognition/exam/CRUST-1/connectivity/outcome_results")

#save 
write.csv(TAT_C_table_inc, file = "TATC_lattice_100.csv", row.names = FALSE)

#clear environment
rm(list=ls())

```

