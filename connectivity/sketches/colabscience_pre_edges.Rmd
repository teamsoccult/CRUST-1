---
title: "collaborative"
author: "Victor MÃ¸ller"
date: "25 sep 2019"
output: html_document
---

Prep to test code (also need to run ABM2 / or something else)

```{r}
net_type <- "Small"
sigma <- 0.2 #0.2 & 0.8 deleted. 
sampleSize <- 20 #20 deleted. 
pop_type <- "All"
tMod <- 2
modelCompare <- BIC
```

```{r setup, include=FALSE}

parameters <- list()
  
#Has to be done to run all true models in one go. 
trueModel <- some_models[tMod] #tMod er en liste med 2, 7, 13. 
tModel <- strToModel(trueModel, k) #conversion. 
  
    
## Select randomly Global Model and previous Global Model
# Sampling / randomizing stuff. 

g <- sample_smallworld(1, 100, 2, 0.05)
V(g)$type <- sample(c("Bo", "Mave", "Tess"))

# Sampling agents 
V(g)$type <- sample(V(g)$type)
V(g)$name <- make.unique(V(g)$type) 
V(g)$model <- sample(some_models)
V(g)$model <- sample(V(g)$model)
matrix_g <- as_adjacency_matrix(g, sparse = F) 
agentTurn <- sample(V(g)$name, size = 11000, replace = T) 
    
## Generate Xset and deterministic value of the linear regression
#trueModel <- some_models[replica]
#tModel <- strToModel(trueModel, k)
Xset <- generateXSet(sampleSize, k, correlation)
tModelBetas <- getBetas(tModel, weights, sigma)
deterministic <- calculateDet(tModel, Xset, weights, tModelBetas)
#######################
## OUTPUT PARAMETERS
#######################
output <- matrix(data=NA, nrow=turns, ncol=O_NUM_FIELDS)

#######################
## SIMULATION EXECUTION
#######################
turn <- 1 
study <- 0
    

      
## initialize parameters 
edges_testing <- 0 
edges_changing <- 0 
edges_already_true <- 0 
edges_already_true_changing <- 0 
edges_already_true_rejecting <- 0 
edges_replication_study <- 0 
edges_replicated <- 0 
edges_not_replicated <- 0
edges_total <- NULL 
edges_not_same_global <- NULL #we have this twice.  
edges_same_global <- NULL #we have this twice. 
      
## Select the token of agent
agentToken <- agentTurn[turn] 

## Agents 
agentIndex <- which((V(g)$name) == agentToken)

## model & in format
gModel <- strToModel(V(g)$model[agentIndex], k) #local model


```

collaborative

```{r}

### Collaborative science ? ###

colab <- sample(c('yes', 'no'), size = 1, prob = c(.02, .98))
      
## Makes a list of the agents indexes ##
if(colab == 'yes'){
  agents_testing <- names(which(matrix_g[, agentIndex] == 1))
  agents_testing <- append(agents_testing, 
                           agentToken, after = length(agents_testing))
  #have to create a list, NB. this overwrites the original agentIndex. 
  agentIndex <- list() 
  prop_m <- list() #needs to be reset somewhere else as well. 
  
  for(i in agents_testing){
  agentIndex[i] <- which((V(g)$name) == i)
  }
  
  } else if(colab != 'no'){} #prints NULL

## The usual code adjusted ##

for(i in seq_len(length(agentIndex))){ #does this work though??
  edges_legible <- list() #needs to be reset here. 
  edges_total <- list() #make it empty for every i. 
  edges_total <- names(which(matrix_g[, agentIndex[[i]]] == 1)) 
  #agentIndex[[i]] is needed here because we are using 1,2,3,4.. not their actual
  #index - which is what we want to get. 

## Above should work now ##
  
## continuing ##
  for(j in edges_total){ #looping over those edges. 

          #token for the i'th edge.  
    edgeToken <- j #should be edgeToken, not agentToken (as before)
    
    #index for the i'th edge
    edge_agentIndex <- which((V(g)$name) == edgeToken)
    
    #checking their model against agent on turn. 
    #if same then nothing happens. 
    #if not the same then their token is put into edges_legible
    if(identical(strToModel(V(g)$model[agentIndex[[i]]],k),
                 strToModel(V(g)$model[edge_agentIndex],k))){ #check this code. 
    } else {  
      edges_legible[j] <- edgeToken
    }
  }
        #determining reserach strategy. 
        if(length(edges_legible) == 0){ #if no edges in the list then strat. must be research. 
          strategy <- 'research'
        } else { #if there are edges in the list, then research strat. is probabilistic. 
          strategy <- sample(c('research', 'neighbor'), size = 1, prob = c(.50, .50))
        }
        
        #what happens on RESEARCH (the old system copied)
        if(strategy == "research"){ 
          if(V(g)$type[agentIndex[[i]]] == "Tess"){ 
            prop_m[[i]] <- modelSimilarByTerm(gModel, models, mode="random",
                                        modelSelection=modelSelection)

            ## Mave
          } else if(V(g)$type[agentIndex[[i]]] == "Mave"){
            prop_m[[i]]  <- models[[as.integer(
              runif(1, min=1,max=length(models)+1))]]

            
            ## Bo 
          } else if(V(g)$type[agentIndex[[i]]] == "Bo"){
            prop_m[[i]] <- modelSimilarByInteraction(gModel, models, mode="random",
                                               modelSelection=modelSelection)
          }
          
        } else { #what happens on NEIGHBOR (could be else if, but it has to be if not research)
          chosen_edge <- sample(edges_legible, size = 1) #sampling just 1 from the list. 
          edge_agentIndex <- which((V(g)$name) == chosen_edge) #finding index.
          prop_m[[i]] <- strToModel(V(g)$model[edge_agentIndex],k) #finding model.
        }
  }

### modelselection ###
### Just chosing randomly for now ###

colab_model <- sample(prop_m, size = 1) #not necessarily a colab mod. just the mod. 
                                          #we just need to flag meta. 

#some NA at the moment, because of "Y ~ X1.." instead of " X1.."
#model <- strToModel(colab_mod,k) #model is the colab model. 

### Testing the colab mod ###

if(colab == "yes"){ #maybe just no matter what. 
  #sample size change. 
  sampleSize_colab <- length(agentIndex) * sampleSize
  
  #changing xset, etc. (this is where my understanding breaks down.)
  Xset_colab <- generateXSet(sampleSize_colab, k, correlation)
  tModelBetas_colab <- getBetas(tModel, weights, sigma)
  deterministic_colab <- calculateDet(tModel, Xset_colab, weights, tModelBetas_colab)
  Yset_colab <- generateY(deterministic_colab, sigma)
  #generating model stats.
  
} else {} #else do nothing. 

#has to happen once only (for it to be the same study). 
Yset <- generateY(deterministic, sigma) #does not need sample size??

#setting up switchmodel
switchModel <- list()

for (i in seq_len(length(agentIndex))){ #checked that gModel works (it does refer to the right ones)
  gModel <- strToModel(V(g)$model[agentIndex[[1]]],k)
  stat <- analysis(colab_model, gModel, Yset_colab, Xset_colab, weights) #needs to be their G. 

  ### MODEL CHANGE ### 
      
      switchModel[i] <- FALSE
      if((modelCompare == TSTATISTICS) &
         (!is.null(stat$model$tstatistics)) &
         (!is.null(stat$gModel$tstatistics)) &
         (!is.na(stat$model$tstatistics)) &
         (!is.na(stat$gModel$tstatistics))){
        if(stat$model$tstatistics > stat$gModel$tstatistics){
          switchModel[i] <- TRUE
        }
      } else if((modelCompare == RSQ) &
                (!is.null(stat$model$rsq)) &
                (!is.null(stat$gModel$rsq)) &
                (!is.na(stat$model$rsq)) &
                (!is.na(stat$gModel$rsq))){
        if(stat$model$rsq > stat$gModel$rsq){
          switchModel[i] <- TRUE
        }
      } else if((modelCompare == AIC) &
                (!is.null(stat$model$aic)) &
                (!is.null(stat$gModel$aic)) &
                (!is.na(stat$model$aic)) &
                (!is.na(stat$gModel$aic))){
        if(stat$model$aic < stat$gModel$aic){
          switchModel[i] <- TRUE
        }
      } else if((modelCompare == BIC) &
                (!is.null(stat$model$bic)) &
                (!is.null(stat$gModel$bic)) &
                (!is.na(stat$model$bic)) &
                (!is.na(stat$gModel$bic))){
        if(stat$model$bic < stat$gModel$bic){
          switchModel[i] <- TRUE
        }
      } else if((modelCompare == ARSQ) &
                (!is.null(stat$model$arsq)) &
                (!is.null(stat$gModel$arsq)) &
                (!is.na(stat$model$arsq)) &
                (!is.na(stat$gModel$arsq))){
        if(stat$model$arsq > stat$gModel$arsq){
          switchModel[i] <- TRUE
        }
      }
      
      #we need to figure out what we use this for. 
      #initGModel <- gModel  --> what does this do?
      #initGModelStat <- stat$gModel --> what does this do?
      
      ### now they switch ###
      if(switchModel[[i]]){ #already is a TRUE/FALSE variable.
        #from the old. 
        #old_gModel <- gModel 
        #above commented out (logging the old model for replication).
        gModel <- colab_model 
        #finalGModelStat <- stat$model : commented out for now. 
        #local change of model
        modelStr <- modelToStr(gModel)
        modelStr <- str_replace(modelStr, "Y ~", "")
        modelStr <- str_replace_all(modelStr, ":", "")
        V(g)$model[agentIndex[[i]]] <- modelStr
        print(modelStr)
      } else {
        #finalGModelStat <- stat$gModel --> what does this do?
      }
      
      ### end of original turn ### 
      
      ### which edges should test ###
}




```

