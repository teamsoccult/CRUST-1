---
title: "own loop"
author: "Mikkel Werling"
date: "5/10/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

```{r}
library(pacman)
p_load(igraph, stringr, ggraph, wesanderson, cowplot, caTools)
```


paths

```{r}
baseDir <- "."
scriptDir <- paste0(baseDir, "/src/functions")
inputDir <- paste0(baseDir, "/data")
outputDir <- paste0(baseDir, "/data")
```

functions

```{r}
source(paste0(scriptDir, "/analysis.R"))
source(paste0(scriptDir, "/calculateDet.R"))
source(paste0(scriptDir, "/calculateDistance.R"))
source(paste0(scriptDir, "/compareModels.R"))
source(paste0(scriptDir, "/constants.R"))
source(paste0(scriptDir, "/convertBinary.R"))
source(paste0(scriptDir, "/generateBetas.R"))
source(paste0(scriptDir, "/generateModels.R"))
source(paste0(scriptDir, "/generateXSet.R"))
source(paste0(scriptDir, "/generateY.R"))
source(paste0(scriptDir, "/getBetas.R"))
source(paste0(scriptDir, "/getPredictors.R"))
source(paste0(scriptDir, "/modelSimilarByInteraction.R"))
source(paste0(scriptDir, "/modelSimilarByTerm.R"))
source(paste0(scriptDir, "/modelToStr.R"))
source(paste0(scriptDir, "/searchModel.R"))
source(paste0(scriptDir, "/seedGenerator.R"))
source(paste0(scriptDir, "/simulator.R"))
source(paste0(scriptDir, "/strToModel.R"))
```

input parameters

```{r}

## Number of replications
replications <- 2 #100 originally, now 2. 

## Length of the simulation
timesteps <- 11000

## Number of factors
k <- 3

## Sigma (Error variance)
sigma <- 0.2

## Sample size
sampleSize <- 100

## generating 
models <- generateModels(k)

## Identify the number of predictors of each model
predictors <- getPredictors(models)

## Generate Betas
weights <- generateBetas(models)

## True model
trueModel <- "x1 + x2"
tModel <- strToModel(trueModel, k)

## Correlation
correlation <- 0.2

```



```{r}
g <- sample_smallworld(1, 100, 5, 0.05) #same as our lattice, but with a rewiring probability of 0.05
 
 V(g)$name <- sample(c("Bo", "Mave", "Tess"))
 V(g)$name <- sample(V(g)$name)
 V(g)$type <- V(g)$name
 V(g)$name <- make.unique(V(g)$name)
```

Checking whether or not the adjacency matrix can be used for checking whether or not egdes of the agents can be called here

```{r}

matrix_g <- as_adjacency_matrix(g, sparse = F) #getting only the matrix from the igraph object

matrix_g["Tess.7", "Mave.7"] == 1 #are these two agents connected?

matrix_g["Mave.7", "Tess.7"] == 1 #does it work the other way around?

matrix_g <- as.matrix(matrix_g) #setting the type to matrix, just because matrix

```

Testing if a certain approach could work for the loop

```{r}
testing <- sample(V(g)$name, size = 11000, replace = T) #sampling the networks agent's names, and doing it for however many rounds we want the simulation to run

table(testing) #testing how many rounds each agents are going to have

testing[12] #arbitrarily choosing a round from the previous string

number <- which((V(g)$name == testing[12])) #figuring out what agent in the network corresponds to the one's who's currently on turn

current_type <- V(g)$type[number] #having a parameter that changes according to what type of agent is currently on turn, in order to late call upon this for choosing strategy

edgy <- names(which(matrix_g[, testing[12]] == 1)) #calling upon the previous egde-matrix, to see what agents are on turn for "bonus round"

V(g)$model <- as.factor(sample(1:14)) #giving each agent a model

V(g)$model[number] <- 13 #seeing if you can change the models of an agent

V(g)$model #you can

models <- generateModels(k) #need something here. 

some_models <- NULL

N = 1

some_models[N] <- modelToStr(models[[N]])

N  <- N + 1 

some_models[N] <- modelToStr(models[[N]])

N  <- N + 1 
some_models[N] <- modelToStr(models[[N]])
N  <- N + 1 
some_models[N] <- modelToStr(models[[N]])

N  <- N + 1 
some_models[N] <- modelToStr(models[[N]])

N  <- N + 1 
some_models[N] <- modelToStr(models[[N]])

N  <- N + 1 
some_models[N] <- modelToStr(models[[N]])
N  <- N + 1 
some_models[N] <- modelToStr(models[[N]])

N  <- N + 1 
some_models[N] <- modelToStr(models[[N]])

N  <- N + 1 
some_models[N] <- modelToStr(models[[N]])

N  <- N + 1 

some_models[N] <- modelToStr(models[[N]])
N  <- N + 1  
some_models[N] <- modelToStr(models[[N]])

N  <- N + 1 
some_models[N] <- modelToStr(models[[N]])

N  <- N + 1 
some_models[N] <- modelToStr(models[[N]])

V(g)$model <- sample(some_models)

V(g)$model <- sample(V(g)$model)

model_in_format <- strToModel(V(g)$model[12], k)

#For mave

model <- models[[as.integer(runif(1, min=1, max=length(models)+1))]]

V(g)$model[number] <- modelToStr(model)

#For Tess

number <- which((V(g)$name == testing[14])) #figuring out what agent in the network corresponds to the one's who's currently on turn

current_type <- V(g)$type[number] #now a tess

modelSelection <- "soft"

model_tess <- modelSimilarByTerm(strToModel(V(g)$model[number], k), models, mode="random",
                                    modelSelection=modelSelection)

V(g)$model[number] <- model_tess

#For Bo

number <- which((V(g)$name == testing[31])) #figuring out what agent in the network corresponds to the one's who's currently on turn

current_type <- V(g)$type[number] #now a Bo

modelSelection <- "soft"

V(g)$model

bo_models <- strToModel(V(g)$model[number], k)

#issue. 
model_bo <- modelSimilarByInteraction(bo_models, models, mode="random",
                                    modelSelection=modelSelection)

modelSimilarByInteraction(model_in_format[3], models, mode="random",
                                    modelSelection=modelSelection)
```

Loop

```{r}

#prior to loop.
#1: network generated.
#2: starting "local" models generated. 

simulator <- function(replications, timesteps, models, k, tModel,
    nRey, nTess, nBo, nMave, weights, sampleSize, correlation, sigma,
    modelCompare, modelSelection, inputDir, outputDir, outputFile, paramFile,
    verbose, ndec, seeds){
  
#models 
model1 <- models[[as.integer(runif(1, min=1, max=length(models) + 1))]]
model2 <- gModel #for the agent

#creating a numeric with 11000 entries (each corresponding to an turn/agent)
agentTurn <- sample(V(g)$name, size = 11000, replace = T)  

#for output
output <- matrix(data=NA, nrow=timesteps, ncol=O_NUM_FIELDS)

#for 11000 timesteps
for(step in 1:timesteps){ #11000 time-steps
      if(verbose){ #error
        print(paste0(replica, " ", step))
      }

      ## Select the token of agent
      agentToken <- agentTurn[step] 
      
      ## Agents 
      agentIndex <- which((V(g)$name) == agentToken)
      
      ## model & in format
      lModel <- stringToModel(V(g)$model[agentIndex], k) #local model

      ## Tess
      if(str_detect(agentToken, "Tess", negative = FALSE) = TRUE){ #detect
        model <- modelSimilarByTerm(lModel, models, mode="random",
                                    modelSelection=modelSelection)

      ## Mave
      } else if(str_detect(agentToken, "Mave", negative = FALSE) = TRUE){
        model <- models[[as.integer(runif(1, min=1, max=length(models)+1))]]
        
      ## Bo
      } else if(str_detect(agentToken, "Bo", negative = FALSE) = TRUE){
        model <- modelSimilarByInteraction(lModel, models, mode="random",
                                           modelSelection=modelSelection)

      #setting up. 
      model1 <- model
      model2 <- lModel
      
      
#calculating stuff
Xset <- generateXSet(sampleSize, k, correlation)
tModelBetas <- getBetas(tModel, weights, sigma)
deterministic <- calculateDet(tModel, Xset, weights, tModelBetas)

#selecting new models
#Tess
model <- modelSimilarByTerm(gModel, models, mode="random",
                                    modelSelection=modelSelection)
#Bo
model <- modelSimilarByInteraction(gModel, models, mode="random",
                                           modelSelection=modelSelection)
#Mave
model <- models[[as.integer(runif(1, min=1, max=length(models)+1))]]

#new = model1, global = model2
model1 <- model
model2 <- gModel

#adding variance & statistics for different engines (AIC, BIC)
Yset <- generateY(deterministic, sigma) #putting variance on the deterministic.
stat <- analysis(model, gModel, Yset, Xset, weights) #computing all the shit.

#smooth -> should we switch
      switchModel <- FALSE
      if((modelCompare == TSTATISTICS) &
          (!is.null(stat$model$tstatistics)) &
          (!is.null(stat$gModel$tstatistics)) &
          (!is.na(stat$model$tstatistics)) &
          (!is.na(stat$gModel$tstatistics))){
        if(stat$model$tstatistics > stat$gModel$tstatistics){
          switchModel <- TRUE
        }
      } else if((modelCompare == RSQ) &
          (!is.null(stat$model$rsq)) &
          (!is.null(stat$gModel$rsq)) &
          (!is.na(stat$model$rsq)) &
          (!is.na(stat$gModel$rsq))){
        if(stat$model$rsq > stat$gModel$rsq){
          switchModel <- TRUE
        }
      } else if((modelCompare == AIC) &
          (!is.null(stat$model$aic)) &
          (!is.null(stat$gModel$aic)) &
          (!is.na(stat$model$aic)) &
          (!is.na(stat$gModel$aic))){
        if(stat$model$aic < stat$gModel$aic){
          switchModel <- TRUE
        }
      } else if((modelCompare == BIC) &
          (!is.null(stat$model$bic)) &
          (!is.null(stat$gModel$bic)) &
          (!is.na(stat$model$bic)) &
          (!is.na(stat$gModel$bic))){
        if(stat$model$bic < stat$gModel$bic){
          switchModel <- TRUE
        }
      } else if((modelCompare == ARSQ) &
          (!is.null(stat$model$arsq)) &
          (!is.null(stat$gModel$arsq)) &
          (!is.na(stat$model$arsq)) &
          (!is.na(stat$gModel$arsq))){
        if(stat$model$arsq > stat$gModel$arsq){
          switchModel <- TRUE
        }
      }

}
```

