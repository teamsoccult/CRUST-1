---
title: "prep_BA_reworkLOOP"
author: "Victor MÃ¸ller"
date: "November 14, 2019"
output: html_document
---
30-11
This document tests & cleans data from Devezer with fixed agents. 
Right now, it takes input from Raw and output to either plotting or outcome. 


```{r}

#packages
library(pacman)
p_load(tidyverse, tidyselect, data.table)

#Naming scheme:
naming_scheme <- "_Devezer_fixed.csv"

```

Relabeling orig_type & modelcompare + taking up to turn 10000

```{r}
#Naming scheme:
naming_scheme <- "_Devezer_fixed.csv"

#Working directory of RAW data. 
setwd("D:/data/Raw data from Computer Room/03-12/raw")

#your files 
files = list.files(pattern=c("*.csv"), full.names=TRUE)

#the function
data_rename <- function(i){
  
  for(i in files){
  
  #where your raw files are:   
  setwd("D:/data/Raw data from Computer Room/03-12/raw")
    
  #reading data:
  data <- read_csv(i)
  data <- na.omit(data)
  data <- tibble::as_tibble(data)
  
  #factorizing (might not work anyways): 
  data <- data %>%
    filter(turn <= 10000) %>%
    mutate(orig_type = factor(orig_type, labels = c("Rey", "Tess", "Bo", "Mave")),
         modelcompare = factor(if_else(modelcompare == 4, "AIC", "BIC")))
  
  #directory for the files: 
  setwd("D:/data/data_prepped_02-12")
  
  #write csv:
  write_csv(data, paste0(i))
  
  }
}

data_rename(files)
```

do we have all files.

```{r}

#Working directory of RAW data. 
setwd("D:/data/data_prepped_02-12")

#which files do we have
files = list.files(pattern=c("*.csv"), full.names=TRUE)

#do we lack anything 

#networks
identifiers <- c( 
              "Mave_", "Tess_", "All_", "Bo_", "Rey_",
              "_0.2_", "_0.5_", "_0.8_", 
              "_AIC_", "_BIC_",
              "_20_", "_100_",
              "_2.csv", "_7.csv", "_13.csv")

for (i in identifiers){
  
network <- noquote(i)

#quick check: 
x <- files
network <- str_detect(files, i)
subset <- x[network]
value <- length(unlist(subset))
print(paste0(value, ": ", i))

}


```

data preparation for "violin_extended_rework": 

```{r}
#Naming scheme:
naming_scheme <- "_Devezer_fixed.csv"

#working directory. 
setwd("D:/data/data_prepped_02-12")
path = "D:/data/data_prepped_02-12"
files <- list.files(path = path, pattern="*.csv")

#initializing empty list 
datalist1 <- list()
datalist2 <- list()

violin_extended_rework <- function(files){
  
  #selecting cols (check )
    mycols <- c("replica", 
            "network", 
            "population", 
            "sigma",
            "modelcompare",
            "base_SS",
            "true_model",
            "orig_type",
            "selected_model",
            "old_model",
            "final_g_true",
            "replicated")
  
  for(i in files){

    #read csv 
    df <- read_csv(i)[mycols]
    
    #as factor
    df <- df %>%
    mutate(network = factor(network),
          population = factor(population),
          sigma = factor(sigma),
          true_model = factor(true_model),
          modelcompare = factor(modelcompare),
          replica = factor(replica),
          base_SS = factor(base_SS),
          orig_type = factor(orig_type))
    
    #create DF. 
    df_basic <- df %>%
      filter(orig_type == "Rey") %>%
        group_by(replica, network, population, sigma, true_model, modelcompare, base_SS) %>%
        summarize(RR = sum(replicated) / n()) 
    
    df_true <- df %>%
      mutate(t_mod_involved = as.numeric(selected_model == true_model | old_model == true_model)) %>%
      filter(orig_type == "Rey", t_mod_involved == 1) %>%
        group_by(replica, network, population, sigma, true_model, modelcompare, base_SS) %>%
        summarize(RR = mean(final_g_true)) 
    
    datalist1[i] <- list(df_basic)
    datalist2[i] <- list(df_true)

  }
    
  df_overall <- do.call("rbind", datalist1)
  df_for_true <- do.call("rbind", datalist2)
  
  #directory for the files: 
  setwd("D:/data/data_plotting")
  
  #write csv:
  write_csv(df_overall, paste0("violin_extended", naming_scheme))
  write_csv(df_for_true, paste0("violin_extended_true", naming_scheme))

}

#calling the function
violin_extended_rework(files)

```

data preparation for "violin_ridges_rework":

NOTE: comparing with tat doesn't make any sense when also grouping with prop_t_mod. 

```{r}

#Naming scheme:
naming_scheme <- "_Devezer_fixed.csv"

#working directory. 
setwd("D:/data/data_prepped_02-12")
path = "D:/data/data_prepped_02-12"
files <- list.files(path = path, pattern="*.csv")

#initializing empty list
datalist1 <- list()
datalist2 <- list()

violin_ridges_rework <- function(files){
 
  #selecting cols (check )
    mycols <- c("replica", 
            "network", 
            "population", 
            "sigma",
            "base_SS",
            "modelcompare",
            "true_model",
            "orig_type",
            "final_g",
            "replicated") #importantly. 
 
  for(i in files){

    #read csv
    df <- read_csv(i)[mycols]
    
    #as factor
    df <- df %>%
    mutate(network = factor(network),
          population = factor(population),
          sigma = factor(sigma),
          modelcompare = factor(modelcompare),
          true_model = factor(true_model),
          base_SS = factor(base_SS))
    
    
    
    #replication rate & TAT overall
    TAT <- df %>%
    group_by(replica, network, population, sigma, true_model, modelcompare, base_SS) %>%
    summarize(TAT = 100 * (sum(as.numeric(final_g == true_model)) / n()))

    RR <- df %>%
    filter(orig_type == "Rey") %>%
    group_by(replica, network, population, sigma, true_model, modelcompare, base_SS) %>%
    summarize(RR = mean(replicated))

    RR_TAT <- merge(TAT, RR)
    
    #replication rate & TAT grouped by 
    
    #replication rate & TAT (for )

    #RR_TF <- df %>%
    #filter(orig_type == "Rey") %>%
    #group_by(replica, network, population, sigma, true_model, modelcompare, base_SS) %>%
    #summarize(RR = mean(replicated))
    
    datalist1[i] <- list(RR_TAT)
    #datalist2[i] <- list(RR_TF)
  }
    
  RR_TAT <- do.call("rbind", datalist1)
  #RR_TF <- do.call("rbind", datalist2)

 
  #directory for the files:
  setwd("D:/data/data_plotting")
 
  #write csv:
  write_csv(RR_TAT, paste0("violin_ridges_RR", naming_scheme))
  #write_csv(RR_TF, paste0("violin_ridges_TF", naming_scheme))

}

#calling the function
violin_ridges_rework(files)

```

### NOT INCLUDING TRUE_FALSE RIGHT NOW - As we're not dealing with proportions, the plots doesn't make any sense. Something akin to that could be made. 

###OUTCOME MEASURES:
____________________
Data prep for "Stickiness":

```{r}
#Naming scheme:
naming_scheme <- "_Devezer_fixed.csv"

#working directory. 
setwd("D:/data/data_prepped_02-12")
path = "D:/data/data_prepped_02-12"
files <- list.files(path = path, pattern="*.csv")

#initializing empty list 
datalist <- list()

stickiness_rework <- function(files){
  
  #selecting cols (check )
    mycols <- c("replica", 
                "network", 
                "population", 
                "sigma",
                "base_SS",
                "modelcompare",
                "true_model",
                "prop_t_mod", #proposed true? (1 = yes, 0 = no). 
                "init_g_true", #count of true orig. (testing) agents.
                "final_g_true")
  
  for(i in files){

    #read csv 
    df <- read_csv(i)[mycols]
    
    #as factor
    df <- df %>%
    mutate(network = factor(network),
          population = factor(population),
          sigma = factor(sigma),
          modelcompare = factor(modelcompare),
          true_model = factor(true_model),
          base_SS = factor(base_SS))
    
    #create DF
    df <- df %>%
      filter(prop_t_mod == 0) %>% #do we really need this filter
      group_by(replica, network, population, sigma, true_model, modelcompare, base_SS) %>%
      summarize(agent_away = sum(as.numeric(init_g_true == 1 & 
                                        final_g_true == 0)),
            agent_total = sum(as.numeric(init_g_true == 1)))
    
    datalist[i] <- list(df)
  }
    
  df_final <- do.call("rbind", datalist)
  
  #directory for the files: 
  setwd("D:/data/data_outcome_measures")
  
  #write csv:
  write_csv(df_final, paste0("stickiness_rework", naming_scheme))

}

#calling the function
stickiness_rework(files)
```

Data prep for TAT_TAT50_rework.Rmd 

```{r}
#Naming scheme:
naming_scheme <- "_Devezer_fixed.csv"

#working directory. 
setwd("D:/data/data_prepped_02-12")
path = "D:/data/data_prepped_02-12"
files <- list.files(path = path, pattern="*.csv")

#initializing empty list 
datalist1 <- list()
datalist2 <- list()

TAT50 <- function(files){
  
  #selecting cols (check )
    mycols <- c("replica", 
                "network", 
                "population", 
                "sigma",
                "base_SS",
                "modelcompare",
                "true_model",
                "final_g")
    
  for(i in files){

    #read csv 
    df <- read_csv(i)[mycols]
    
   #as factor
    df <- df %>%
    mutate(network = factor(network),
          population = factor(population),
          sigma = factor(sigma),
          modelcompare = factor(modelcompare),
          true_model = factor(true_model),
          base_SS = factor(base_SS))
    
    #TAT PER REPLICA
    TAT <- df %>%  
      group_by(replica, network, population, true_model, sigma, base_SS, modelcompare) %>% 
      mutate(TAT = 100 * (sum(as.numeric(final_g == true_model)) / n()),
        TAT_50 = ifelse(TAT >= 50, 1, 0)) %>%
      summarise(TAT = mean(TAT),
                TAT50 = mean(TAT_50)) 
        
    #TAT AVG. OVER REP. 
    TAT_AVG <- df %>%  
      group_by(network, population, true_model, sigma, base_SS, modelcompare) %>% 
      mutate(TAT = 100 * (sum(as.numeric(final_g == true_model)) / n()),
        TAT_50 = ifelse(TAT >= 50, 1, 0)) %>%
      summarise(TAT = mean(TAT),
                TAT50 = mean(TAT_50)) 
    
    datalist1[i] <- list(TAT)
    datalist2[i] <- list(TAT_AVG)
  }
    
  TAT <- do.call("rbind", datalist1)
  TAT_AVG <- do.call("rbind", datalist2)
  
  #directory for the files: 
  setwd("D:/data/data_outcome_measures")
  
  #write csv:
  write_csv(TAT, paste0("TAT_TAT50", naming_scheme))
  write_csv(TAT_AVG, paste0("TAT_TAT50_AVG", naming_scheme))

}

#calling the function
TAT50(files)

```

### TAT_C IS NOT REALLY A MEASURE THAT MAKES SENSE WITH A SINGLE GLOBAL MODEL

First passage (true accept): 

```{r}
#Naming scheme:
naming_scheme <- "_Devezer_fixed.csv"

#working directory. 
setwd("D:/data/data_prepped_02-12")
path = "D:/data/data_prepped_02-12"
files <- list.files(path = path, pattern="*.csv")

#initializing empty list 
datalist1 <- list()

FPTT <- function(files){
  
  #selecting cols (check )
    mycols <- c("replica", 
            "network", 
            "population", 
            "sigma",
            "base_SS",
            "modelcompare",
            "true_model",
            "init_g_true",
            "final_g_true")
    
  for(i in files){

    #read csv 
    df <- read_csv(i)[mycols]
    
    #as factor
    df <- df %>%
    mutate(network = factor(network),
          population = factor(population),
          sigma = factor(sigma),
          true_model = factor(true_model))
    
    #TAT PER REPLICA
    df <- df %>%
      group_by(replica, network, population, true_model, sigma, base_SS, modelcompare) %>%
      summarize(first_row = min(which(final_g_true > init_g_true)))
    
    datalist1[i] <- list(df)
  }
    
  FPTT <- do.call("rbind", datalist1)
  
  #directory for the files: 
  setwd("D:/data/data_outcome_measures")
  
  #write csv:
  write_csv(FPTT, paste0("FPTT", naming_scheme))

}

#calling the function
FPTT(files)

```

