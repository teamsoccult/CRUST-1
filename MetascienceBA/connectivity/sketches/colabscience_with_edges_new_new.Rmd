---
title: "collaborative"
author: "Victor MÃ¸ller"
date: "25 sep 2019"
output: html_document
---

Prep to test code (also need to run ABM2 / or something else)

```{r}
net_type <- "Small"
sigma <- 0.2 #0.2 & 0.8 deleted. 
base_sampleSize <- 20 #20 deleted. 
pop_type <- "All"
tMod <- 2
modelCompare <- BIC
```

```{r setup, include=FALSE}

parameters <- list()
  
#Has to be done to run all true models in one go. 
trueModel <- some_models[tMod] #tMod er en liste med 2, 7, 13. 
tModel <- strToModel(trueModel, k) #conversion. 
  
#BETAS#
tModelBetas <- getBetas(tModel, weights, sigma)
    
## Select randomly Global Model and previous Global Model
# Sampling / randomizing stuff. 

g <- make_lattice(length = 100, dim = 1, 
                        nei = 2, circular = T, directed = F)
V(g)$type <- sample(c("Bo", "Mave", "Tess"))

# Sampling agents 
V(g)$type <- sample(V(g)$type)
V(g)$name <- make.unique(V(g)$type) 
V(g)$model <- sample(some_models)
V(g)$model <- sample(V(g)$model)
matrix_g <- as_adjacency_matrix(g, sparse = F) 
agentTurn <- sample(V(g)$name, size = 11000, replace = T) 
    
## Generate Xset and deterministic value of the linear regression
#trueModel <- some_models[replica]
#tModel <- strToModel(trueModel, k)

#######################
## OUTPUT PARAMETERS
#######################
output <- matrix(data=NA, nrow=turns, ncol=O_NUM_FIELDS)

#######################
## SIMULATION EXECUTION
#######################
turn <- 1 
study <- 0
      
## initialize parameters 
edges_testing <- 0 
edges_changing <- 0 
edges_already_true <- 0 
edges_already_true_changing <- 0 
edges_already_true_rejecting <- 0 
edges_replication_study <- 0 
edges_replicated <- 0 
edges_not_replicated <- 0
edges_not_same_global <- NULL #we have this twice.  
edges_same_global <- NULL #we have this twice. 
      
#TESTED INITIALIZING PARAMETERS:
propModel <- list() #CHANGE IN NAME: from prop_m to propModel
agentsSwitch <- list()
old_gModel <- list() #now a list in order to check replications for colabs. 

## Select the token of agent
agentToken <- agentTurn[turn] 

## Agents 
agentIndex <- which((V(g)$name) == agentToken)
agentOriginal <- agentIndex #now we have the information logged - but do we need it? If we don't need to log it, than it should be removed

## model & in format
#gModel <- strToModel(V(g)$model[agentIndex], k) #local model


```

collaborative

```{r}

### Collaborative science ? ###

colab <- sample(c('yes', 'no'), size = 1, prob = c(.02, .98))
      
## Makes a list of the agents indexes ##

agents_testing <- names(which(matrix_g[, agentIndex] == 1))
agents_testing <- append(agents_testing, 
                           agentToken, after = length(agents_testing))

if(colab == 'yes'){
  #have to create a list, NB. this overwrites the original agentIndex. 
  agentIndex <- list() #maybe not overwrite. 
  
  for(i in agents_testing){
  agentIndex[i] <- which((V(g)$name) == i)
  }
  
  } else if(colab == 'no'){} #prints NULL

## The usual code adjusted ##

for(i in seq_len(length(agentIndex))){ #does this work though??
  edges_legible <- list() #needs to be reset here. 
  edges_total <- list() #make it empty for every i - consider deleting in the beginning. 
  edges_total <- names(which(matrix_g[, agentIndex[[i]]] == 1)) 
  #agentIndex[[i]] is needed here because we are using 1,2,3,4.. not their actual
  #index - which is what we want to get. 
  gModel <- strToModel(V(g)$model[agentIndex[[i]]], k)
## Above should work now ##
  
## continuing ##
  for(j in edges_total){ #looping over those edges. 

          #token for the i'th edge.  
    edgeToken <- j #should be edgeToken, not agentToken (as before)
    
    #index for the i'th edge
    edge_agentIndex <- which((V(g)$name) == edgeToken)
    
    #checking their model against agent on turn. 
    #if same then nothing happens. 
    #if not the same then their token is put into edges_legible
    if(identical(strToModel(V(g)$model[agentIndex[[i]]],k),
                 strToModel(V(g)$model[edge_agentIndex],k))){ #check this code. 
    } else {  
      edges_legible[j] <- edgeToken
    }
  }
        #determining reserach strategy. 
        if(length(edges_legible) == 0){ #if no edges in the list then strat. must be research. 
          strategy <- 'research'
        } else { #if there are edges in the list, then research strat. is probabilistic. 
          strategy <- sample(c('research', 'neighbor'), size = 1, prob = c(.50, .50))
        }
        
        #what happens on RESEARCH (the old system copied)
        if(strategy == "research"){ 
          if(V(g)$type[agentIndex[[i]]] == "Tess"){ 
            propModel[[i]] <- modelSimilarByTerm(gModel, models, mode="random",
                                        modelSelection=modelSelection)

            ## Mave
          } else if(V(g)$type[agentIndex[[i]]] == "Mave"){
            propModel[[i]]  <- models[[as.integer(
              runif(1, min=1,max=length(models)+1))]]

            
            ## Bo 
          } else if(V(g)$type[agentIndex[[i]]] == "Bo"){
            propModel[[i]] <- modelSimilarByInteraction(gModel, models, mode="random",
                                               modelSelection=modelSelection)
          }
          
        } else { #what happens on NEIGHBOR (could be else if, but it has to be if not research)
          chosen_edge <- sample(edges_legible, size = 1) #sampling just 1 from the list. 
          edge_agentIndex <- which((V(g)$name) == chosen_edge) #finding index.
          propModel[[i]] <- strToModel(V(g)$model[edge_agentIndex],k) #finding model.
        }
  }

### modelselection ###
### Just chosing randomly for now ###

model <- sample(propModel, size = 1) 
model <- model[[1]]
## this becomes the equivalent of "model" from the old code. 
## I.e., the model that is being tested. 

#some NA at the moment, because of "Y ~ X1.." instead of " X1.."
#model <- strToModel(colab_mod,k) #model is the colab model. 

### Testing the colab mod ###

## generate stuff ##
## who's models? ##
sampleSize <- length(agentIndex) * base_sampleSize
Xset <- generateXSet(sampleSize, k, correlation)
deterministic <- calculateDet(tModel, Xset, weights, tModelBetas)
Yset <- generateY(deterministic, sigma)

for (i in seq_len(length(agentIndex))){ #checked that gModel works (it does refer to the right ones)
  gModel <- strToModel(V(g)$model[agentIndex[[i]]],k) #something here..
  stat <- analysis(model, gModel, Yset, Xset, weights) 
  #now model refers to the colab model & gModel is looped over. 

  ### MODEL CHANGE ### 
  ### I don't think that switchmodel has to be a list. 
      
      switchModel <- FALSE
      if((modelCompare == TSTATISTICS) &
         (!is.null(stat$model$tstatistics)) &
         (!is.null(stat$gModel$tstatistics)) &
         (!is.na(stat$model$tstatistics)) &
         (!is.na(stat$gModel$tstatistics))){
        if(stat$model$tstatistics > stat$gModel$tstatistics){
          switchModel <- TRUE
        }
      } else if((modelCompare == RSQ) &
                (!is.null(stat$model$rsq)) &
                (!is.null(stat$gModel$rsq)) &
                (!is.na(stat$model$rsq)) &
                (!is.na(stat$gModel$rsq))){
        if(stat$model$rsq > stat$gModel$rsq){
          switchModel <- TRUE
        }
      } else if((modelCompare == AIC) &
                (!is.null(stat$model$aic)) &
                (!is.null(stat$gModel$aic)) &
                (!is.na(stat$model$aic)) &
                (!is.na(stat$gModel$aic))){
        if(stat$model$aic < stat$gModel$aic){
          switchModel <- TRUE
        }
      } else if((modelCompare == BIC) &
                (!is.null(stat$model$bic)) &
                (!is.null(stat$gModel$bic)) &
                (!is.na(stat$model$bic)) &
                (!is.na(stat$gModel$bic))){
        if(stat$model$bic < stat$gModel$bic){
          switchModel <- TRUE
        }
      } else if((modelCompare == ARSQ) &
                (!is.null(stat$model$arsq)) &
                (!is.null(stat$gModel$arsq)) &
                (!is.na(stat$model$arsq)) &
                (!is.na(stat$gModel$arsq))){
        if(stat$model$arsq > stat$gModel$arsq){
          switchModel <- TRUE
        }
      }
      
      #we need to figure out what we use this for. 
      initGModel <- gModel #what does this do?
      initGModelStat <- stat$gModel #what does this do?
      
      ### now they switch ###
      if(switchModel){ #already is a TRUE/FALSE variable.
        #from the old. 
        old_gModel[[i]] <- gModel #do we use this? if we need to use this, it needs to be lists
        finalGModelStat <- stat$model #do we use this?
        #local change of model
        modelStr <- modelToStr(model)
        modelStr <- str_replace(modelStr, "Y ~", "")
        modelStr <- str_replace_all(modelStr, ":", "")
        V(g)$model[agentIndex[[i]]] <- modelStr
        agentsSwitch[[i]] <- agentIndex[[i]] #small bug here, return (perhaps still) 
      } else {
        #finalGModelStat <- stat$gModel --> what does this do?
      }
    
}

#making the variable that we base the rest on.. 
agentsSwitch = agentsSwitch[-which(sapply(agentsSwitch, is.null))]
old_gModel = old_gModel[-which(sapply(old_gModel, is.null))]

```



```{r}

      ### IF MODEL-SWITCH THEN EDGES NOW TEST ### 
      ### EVERYTHING CALLED "SWITCH" SOMETHING ###

## initialize parameters 
      switch_testing <- 0 #USED
      switch_changing <- 0 
      switch_already_true <- 0 
      switch_already_true_changing <- 0 
      switch_already_true_rejecting <- 0 
      switch_replication_study <- 0 
      switch_replicated <- 0 
      switch_not_replicated <- 0
      switch_total <- NULL 
      switch_not_same_global <- NULL #we have this twice.  
      switch_same_global <- NULL #we have this twice. 

if(length(agentsSwitch) != 0){ #only if some changed. 
  
  #prep for nested loop. 
  for(i in seq_len(length(agentsSwitch))){
    switch_initial <- names(which(matrix_g[, agentsSwitch[[i]]] == 1)) #new names
    switch_total <- setdiff(switch_initial, agents_testing) 
    #agents_testing is from the "new code". 
    
    
    for(j in switch_total){
      switch_agentToken <- j
      switch_agentIndex <- which((V(g)$name) == switch_agentToken)
      switch_gModel <- strToModel(V(g)$model[switch_agentIndex],k)
      
      if(!compareModels(switch_gModel, model)){ #changed to model instead of gModel
        switch_not_same_global <- c(switch_not_same_global, switch_agentToken)
        } else {
        switch_same_global <- c(switch_same_global, switch_agentToken)
        }
    }
  
  
  ## making switch_not_same_global / switch_same_global unique. 
  if(length(switch_same_global) > 0){
    switch_same_global <- unique(unlist(strsplit(switch_same_global, " "))) #hmm..
  }
  if(length(switch_same_global) > 0){
    switch_not_same_global <- unique(unlist(strsplit(switch_not_same_global, " "))) #hmm..
  }


    ### THE EDGES WITH DIFF. GLOBAL MOD. NOW TEST ### 
        
    for(y in switch_not_same_global){ 
      switch_testing <- switch_testing + 1 
      switch_agentToken <- y
      
      ## Agents 
      switch_agentIndex <- which((V(g)$name) == switch_agentToken) #new change.
      
      ## model & in format
      switch_gModel <- strToModel(V(g)$model[switch_agentIndex], k) #new change.
      
      ## tried replication
      switch_replication_study <- switch_replication_study + 
        as.numeric(compareModels(switch_gModel, old_gModel[[i]]))  
      
      ## already at true model (atm). 
      switch_already_true <- switch_already_true + 
        as.numeric(compareModels(tModel, switch_gModel)) #new change. 
      
      ## who's models? ##
      sampleSize <- base_sampleSize
      Xset <- generateXSet(sampleSize, k, correlation)
      deterministic <- calculateDet(tModel, Xset, weights, tModelBetas)
      Yset <- generateY(deterministic, sigma)
      stat <- analysis(model, switch_gModel, Yset, Xset, weights)
          
          #smooth -> should we switch
          switchModel <- FALSE
          if((modelCompare == TSTATISTICS) &
             (!is.null(stat$model$tstatistics)) &
             (!is.null(stat$gModel$tstatistics)) & #is in fact switch_gModel
             (!is.na(stat$model$tstatistics)) &
             (!is.na(stat$gModel$tstatistics))){
            if(stat$model$tstatistics > stat$gModel$tstatistics){
              switchModel <- TRUE
            }
          } else if((modelCompare == RSQ) &
                    (!is.null(stat$model$rsq)) &
                    (!is.null(stat$gModel$rsq)) &
                    (!is.na(stat$model$rsq)) &
                    (!is.na(stat$gModel$rsq))){
            if(stat$model$rsq > stat$gModel$rsq){
              switchModel <- TRUE
            }
          } else if((modelCompare == AIC) &
                    (!is.null(stat$model$aic)) &
                    (!is.null(stat$gModel$aic)) &
                    (!is.na(stat$model$aic)) &
                    (!is.na(stat$gModel$aic))){
            if(stat$model$aic < stat$gModel$aic){
              switchModel <- TRUE
            }
          } else if((modelCompare == BIC) &
                    (!is.null(stat$model$bic)) &
                    (!is.null(stat$gModel$bic)) &
                    (!is.na(stat$model$bic)) &
                    (!is.na(stat$gModel$bic))){
            if(stat$model$bic < stat$gModel$bic){
              switchModel <- TRUE
            }
          } else if((modelCompare == ARSQ) &
                    (!is.null(stat$model$arsq)) &
                    (!is.null(stat$gModel$arsq)) &
                    (!is.na(stat$model$arsq)) &
                    (!is.na(stat$gModel$arsq))){
            if(stat$model$arsq > stat$gModel$arsq){
              switchModel <- TRUE
            }
          } 
          
          ### IF THEY SHOULD SHIFT ### 
          
          if(switchModel){
            
            #how many changes in total 
            switch_changing <- switch_changing + 1 #new change. 
            
            #replicated
            switch_replicated <- switch_replicated + 
              as.numeric(compareModels(switch_gModel, old_gModel[[i]])) #new change!!
            
            #changed away from true 
            switch_already_true_changing <- switch_already_true_changing + #new change!!
              as.numeric(compareModels(switch_gModel, tModel))
            
            #changing their information 
            modelStr <- modelToStr(switch_gModel)
            modelStr <- str_replace(modelStr, "Y ~", "")
            modelStr <- str_replace_all(modelStr, ":", "")
            V(g)$model[switch_agentIndex] <- modelStr
            
          } 
          
          ### LOGGING REPLICATION INFORMATION ###
          else {
            
            #how many rejected rightfully
            switch_already_true_rejecting <- switch_already_true_rejecting +
              as.numeric(compareModels(switch_gModel, tModel))
            
            #how many did not replicate
            switch_not_replicated <- switch_not_replicated +
              as.numeric(compareModels(switch_gModel, old_gModel[[i]]))
          }
        }
      }
      
      # how many studies conducted? 
      study <- study + (length(agentIndex) + edges_testing)
    }
  }
}


####GENERATING MODELS FOR SWITCH #####
        
        
for(i in switch_not_same_global){ 
          
          ## tried 
          edges_testing <- edges_testing + 1 #how many tested. 
          
          ## which one 
          agentToken <- i
          
          ## Agents 
          edge_agentIndex <- which((V(g)$name) == agentToken) #new change.
          
          ## model & in format
          edge_gModel <- strToModel(V(g)$model[edge_agentIndex], k) #new change.
          
          ## tried replication
          edges_replication_study <- edges_replication_study + 
            as.numeric(compareModels(edge_gModel, old_gModel)) 
          
          #adding variance & statistics for different engines (AIC, BIC)
          Yset <- generateY(deterministic, sigma) #putting variance on the                  deterministic.
          stat <- analysis(gModel, edge_gModel, Yset, Xset, weights) #new change!! 
          
          ## already at true model (atm). 
          edges_already_true <- edges_already_true + 
            as.numeric(compareModels(tModel, edge_gModel)) #new change. 
          
          #smooth -> should we switch
          edge_switchModel <- FALSE
          if((modelCompare == TSTATISTICS) &
             (!is.null(stat$model$tstatistics)) &
             (!is.null(stat$gModel$tstatistics)) & #is in fact edge_gModel
             (!is.na(stat$model$tstatistics)) &
             (!is.na(stat$gModel$tstatistics))){
            if(stat$model$tstatistics > stat$gModel$tstatistics){
              edge_switchModel <- TRUE
            }
          } else if((modelCompare == RSQ) &
                    (!is.null(stat$model$rsq)) &
                    (!is.null(stat$gModel$rsq)) &
                    (!is.na(stat$model$rsq)) &
                    (!is.na(stat$gModel$rsq))){
            if(stat$model$rsq > stat$gModel$rsq){
              edge_switchModel <- TRUE
            }
          } else if((modelCompare == AIC) &
                    (!is.null(stat$model$aic)) &
                    (!is.null(stat$gModel$aic)) &
                    (!is.na(stat$model$aic)) &
                    (!is.na(stat$gModel$aic))){
            if(stat$model$aic < stat$gModel$aic){
              edge_switchModel <- TRUE
            }
          } else if((modelCompare == BIC) &
                    (!is.null(stat$model$bic)) &
                    (!is.null(stat$gModel$bic)) &
                    (!is.na(stat$model$bic)) &
                    (!is.na(stat$gModel$bic))){
            if(stat$model$bic < stat$gModel$bic){
              edge_switchModel <- TRUE
            }
          } else if((modelCompare == ARSQ) &
                    (!is.null(stat$model$arsq)) &
                    (!is.null(stat$gModel$arsq)) &
                    (!is.na(stat$model$arsq)) &
                    (!is.na(stat$gModel$arsq))){
            if(stat$model$arsq > stat$gModel$arsq){
              edge_switchModel <- TRUE
            }
          } 
          
          ### IF THEY SHOULD SHIFT ### 
          
          if(edge_switchModel){
            
            #how many changes in total 
            edges_changing <- edges_changing + 1 #new change. 
            
            #replicated
            edges_replicated <- edges_replicated + 
              as.numeric(compareModels(edge_gModel, old_gModel)) #new change!!
            
            #changed away from true 
            edges_already_true_changing <- edges_already_true_changing + #new change!!
              as.numeric(compareModels(edge_gModel, tModel))
            
            #changing their information 
            modelStr <- modelToStr(edge_gModel)
            modelStr <- str_replace(modelStr, "Y ~", "")
            modelStr <- str_replace_all(modelStr, ":", "")
            V(g)$model[edge_agentIndex] <- modelStr
            
          } 
          
          ### LOGGING REPLICATION INFORMATION ###
          else {
            
            #how many rejected rightfully
            edges_already_true_rejecting <- edges_already_true_rejecting +
              as.numeric(compareModels(edge_gModel, tModel))
            
            #how many did not replicate
            edges_not_replicated <- edges_not_replicated +
              as.numeric(compareModels(edge_gModel, old_gModel))
          }
        }
      }
      
      # how many studies conducted? 
      study <- study + (length(agentIndex) + edges_testing)
```

